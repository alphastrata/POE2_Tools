use regex::Regex;
use serde_json::Value;
use std::{collections::BTreeMap, env, fs, io::Write, path::Path};

// for generating the Stat deserializer impl
use serde::{
    de::{Deserializer, Error},
    Deserialize,
};
use std::collections::HashMap;

struct StatEntry {
    variant: String,   // CamelCase variant name
    original: String,  // original key
    type_name: String, // Math type
}

fn to_camel_case(s: &str) -> String {
    s.split('_')
        .filter(|w| !w.is_empty())
        .map(|w| {
            let mut c = w.chars();
            match c.next() {
                None => String::new(),
                Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
            }
        })
        .collect()
}

fn main() {
    let data_path = "../../data/POE2_Tree.json";
    println!("cargo:rerun-if-changed={}", data_path);
    let dataset = fs::read_to_string(data_path).unwrap();
    let root: serde_json::Map<String, Value> = serde_json::from_str(&dataset).unwrap();

    let passive_skills = root
        .get("passive_skills")
        .and_then(|v| v.as_object())
        .expect("Expected 'passive_skills' key to be an object");

    let mut stats: BTreeMap<String, StatEntry> = BTreeMap::new();
    let underscore_re = Regex::new(r"_+").unwrap();
    let sign_re = Regex::new(r"^(?P<base>.*?)(?:_)?(?P<sign>[+\-*/%])$?").unwrap();

    for (_, obj) in passive_skills {
        if let Some(stats_obj) = obj.get("stats").and_then(|v| v.as_object()) {
            for key in stats_obj.keys() {
                if key.chars().any(|c| c.is_ascii_digit()) {
                    eprintln!("Ignoring stat with digit: {}", key);
                    continue;
                }
                let (base, type_name) = if let Some(caps) = sign_re.captures(key) {
                    let base = caps.name("base").unwrap().as_str();
                    let sign = caps.name("sign").unwrap().as_str();
                    let t = match sign {
                        "+" => "Plus",
                        "-" => "Minus",
                        "*" => "Multiply",
                        "/" => "Divide",
                        "+%" => "PlusPercentage",
                        "-%" => "MinusPercentage",
                        _ => "Other",
                    };
                    (base.to_string(), t)
                } else {
                    (key.to_string(), "Other")
                };

                let collapsed = underscore_re.replace_all(&base, "_");
                let sanitized = collapsed.trim_matches('_').to_string();
                if sanitized.is_empty() {
                    eprintln!("Ignoring stat that sanitizes to empty: {}", key);
                    continue;
                }
                let variant = to_camel_case(&sanitized);
                stats.entry(variant.clone()).or_insert(StatEntry {
                    variant,
                    original: key.to_string(),
                    type_name: type_name.to_string(),
                });
            }
        }
    }

    let dest_path = Path::new("src/stats/stat.rs");
    let mut file = fs::File::create(&dest_path).unwrap();

    writeln!(file, "// @generated by build.rs").unwrap();
    writeln!(file, "use super::arithmetic::*;").unwrap();
    writeln!(
        file,
        "use serde::{{Deserialize, de::{{Deserializer, Error}}}};"
    )
    .unwrap();
    writeln!(file, "use std::collections::HashMap;").unwrap();
    writeln!(file).unwrap();

    writeln!(file, "#[derive(Debug, Clone)]").unwrap();
    writeln!(file, "pub enum Stat {{").unwrap();
    for entry in stats.values() {
        writeln!(file, "    {}({}),", entry.variant, entry.type_name).unwrap();
    }
    writeln!(file, "    Unknown(String, f32),").unwrap();
    writeln!(file, "}}").unwrap();
    writeln!(file).unwrap();

    // from_key_value
    writeln!(file, "impl Stat {{").unwrap();
    writeln!(
        file,
        "    pub fn from_key_value(k: &str, v: u16) -> Self {{"
    )
    .unwrap();
    writeln!(file, "        match k {{").unwrap();
    for entry in stats.values() {
        writeln!(
            file,
            "            \"{}\" => Stat::{}({}(v as f32)),",
            entry.original, entry.variant, entry.type_name
        )
        .unwrap();
    }
    writeln!(
        file,
        "            _ => Stat::Unknown(k.to_string(), v as f32),"
    )
    .unwrap();
    writeln!(file, "        }}").unwrap();
    writeln!(file, "    }}").unwrap();
    writeln!(file).unwrap();

    // as_str
    writeln!(file, "    pub fn as_str(&self) -> &str {{").unwrap();
    writeln!(file, "        match self {{").unwrap();
    for entry in stats.values() {
        writeln!(
            file,
            "            Stat::{}(_) => \"{}\",",
            entry.variant, entry.original
        )
        .unwrap();
    }
    writeln!(file, "            Stat::Unknown(s, _) => s.as_str(),").unwrap();
    writeln!(file, "        }}").unwrap();
    writeln!(file, "    }}").unwrap();
    writeln!(file, "}}").unwrap();
    writeln!(file).unwrap();

    // generated deserializer
    writeln!(file, "impl<'de> Deserialize<'de> for Stat {{").unwrap();
    writeln!(
        file,
        "    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>"
    )
    .unwrap();
    writeln!(file, "    where D: Deserializer<'de>,").unwrap();
    writeln!(file, "    {{").unwrap();
    writeln!(
        file,
        "        let key_value: HashMap<String, u16> = Deserialize::deserialize(deserializer)?;"
    )
    .unwrap();
    writeln!(file, "        for (k, v) in key_value.into_iter() {{").unwrap();
    writeln!(file, "            return Ok(match k.as_str() {{").unwrap();
    for entry in stats.values() {
        writeln!(
            file,
            "                \"{}\" => Stat::{}({}(v as f32)),",
            entry.original, entry.variant, entry.type_name
        )
        .unwrap();
    }
    writeln!(file, "                _ => Stat::Unknown(k, v as f32),").unwrap();
    writeln!(file, "            }});").unwrap();
    writeln!(file, "        }}").unwrap();
    writeln!(
        file,
        "        Err(Error::custom(\"Expected at least one stat\"))"
    )
    .unwrap();
    writeln!(file, "    }}").unwrap();
    writeln!(file, "}}").unwrap();

    println!("Generated stat.rs at {:?}", dest_path);
}
